<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" autor="Nicolas Le Galvic - Enzo Côme" description="Processus de création du jeu et de la résolution">
    <title>Concrétisation P5</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Bienvenue dans le Monde de Notre Jeu</h1>
        <nav>
            <ul>
                <li><a href="main.html">Le Projet</a></li>
                <li><a href="groupe.html">Notre Groupe</a></li>
                <li><a href="rules.html">Les regles du jeu</a></li>
                <li><a href="creation-process.html">Processus de Création / Présentation de l'algorithme</a></li>
                <br>
                <li><a href="#creation-process" id="ID_creation-process">Processus de Création</a></li>
                <li><a href="#algo-presentation" id="ID_algo-presentation">Présentation de l'algorithme</a></li>
            </ul>
        </nav>
    </header>
    
    <section id="creation-process">
        <h2>Processus de Création</h2>
        <p>Le processus de création du jeu a été une aventure en soi. Nous avons deux programmes, le premier qui est le jeu en tant que tels, et le second qui est l'algorithme de résolution. Voici le'historique de l'avancée de chaque programme :</p>
        <h2>Jeu:</h2>
        <ol>
            <li>Conceptualisation de l'idée, des contraintes et répartitions des taches</li>
            <li>Programmation de la partie jeu</li>
            <ol class="sous liste">
                <li>Création du programme , génération et affichage de la grille dans le terminal (V1)</li>
                <li>Création de la page (V2)</li>
                <li>Correctif de bug majeurs (V3)</li>
                <li>Traitement d'image & grille du jeu (V4)</li>
                <li>Relecture & réagancement & nettoyage du programme (V5)</li>
                <li>Implémentation d'un menu pour entré les dimensions de la grille (V6)</li>
                <li>Correctif de bug majeurs (V7)</li>
                <li>Première version jouable en noir et blanc (V8 & V9)</li>
                <li>Première version jouable en couleur (V10)</li>
                <li>Ajout de la création de grille aléatoirement (V11)</li>
            </ol>
            
        </ol>
        <p>Notre équipe a travaillé sans relâche pour offrir une expérience de jeu inoubliable.</p>
    </section>
    <section id="algo-presentation">
        <h2>Présentation de l'algorithme</h2>

        <pre>
Notre projet nous a conduit à développer un solveur de nonogrammes. 
Pour ce faire, nous avons adopté une stratégie consistant à résoudre nous-mêmes des nonogrammes afin de comprendre comment élaborer un solveur.
Lors de nos essais, nous avons découvert des procédés particuliers.
Parmi ceux-ci, nous avons d'abord identifié la résolution triviale :

Cette dernière est très simple ; elle consiste en la première étape d'une résolution de nonogramme, à savoir compléter une ligne entièrement,
qu'elle soit remplie de True, de False ou qu'elle puisse se résoudre en respectant les indices.
Cette étape initiale est cruciale pour avancer, car sans cela, le début peut s'avérer relativement complexe.

En deuxième étape, il est important de vérifier si le remplissage d'une ligne n'a pas débloqué d'autres lignes.
C'est pourquoi nous avons élaboré des fonctions de remplissage de ligne.
Les deux premières fonctions se chargent de remplir les lignes et colonnes avec des False : 
Pour ce faire, il suffit de vérifier si la somme des indices correspond au nombre de cases déjà coloriées dans les lignes ou colonnes associées.
Ensuite, nous faisons de même pour les True :
Pour cela, nous nous intéressons au nombre de cases non coloriées (None) et au nombre de cases restantes à colorier.
Si nous avons autant de cases en None que de cases restantes à colorier, alors on peut déduire que toutes ces cases sont à colorier.

Après notre résolution par déduction, nous pouvons rapidement nous retrouver bloqués.
Pour remédier à cela, nous avons mis en œuvre des fonctions capables de détecter la présence de cases "obligatoires" :
En effet, lors de la résolution, certaines cases peuvent être obligatoires.
Par exemple, une ligne de 10 cases avec un indice de 8 aura forcément certaines cases coloriées. Pour cela, nous admettons deux cas ;
le pire cas gauche et le pire cas droite , dans le pire cas gauche, nous remplissons les 8 premières cases et dans le pire cas droite,
nous remplissons les 8 dernières cases.
Dans les deux cas nous observons des cases qui sont coloriées , ce sont des cases obligatoires.

Finalement, notre programme se charge de compléter la grille au fur et à mesure.
Il est possible que le solveur ne résolve pas la grille.
Pour cela, nous aurions pu essayer une fonction qui ajoute aléatoirement un True ou un False dans la grille pour débloquer certaines situations.
Nous n'avons pas élaboré cette fonction parce que notre objectif est de reproduire les procédés humains.
Malgré cela, notre solveur est capable de résoudre des grilles efficacement. 
        </pre>
    </section>
    
    <footer>
        <p>&copy; 2024 Concrétisation P5 Nicolas & Enzo. Tous droits réservés.</p><img src="Logo_UA.PNG" alt="Logo_UA.PNG">
    </footer>
</body>
</html>
